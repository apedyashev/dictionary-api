/* global defaultUser */
const {assert} = require('chai');
const request = require('supertest');
const mongoose = require('mongoose');
const _ = require('lodash');
const slug = require('slug');
const app = require(`${TEST_BASE}/../app.js`);
const {endpoints} = require(`${TEST_BASE}/constants.js`);
const mocks = require(`${TEST_BASE}/mocks`);

describe('Dictionaries Route', () => {
  describe(`PATCH ${endpoints.dictionaries(':id')}`, () => {
    let newDict;
    beforeEach(async () => {
      const dictonary = mocks.dictionary(5);
      await request(app)
        .post(endpoints.dictionaries())
        .set(...defaultUser.authData.header)
        .send(dictonary)
        .expect(201)
        .expect((res) => {
          newDict = res.body.item;
        });
    });

    it('should return 401 if auth header is not set', async () => {
      await request(app)
        .patch(endpoints.dictionaries(newDict.id))
        .send(newDict)
        .expect(401);
    });

    it('should return 422 if dictionary with given translateDirection already exist', async () => {
      const dictonary1 = mocks.dictionary();
      await request(app)
        .post(endpoints.dictionaries())
        .set(...defaultUser.authData.header)
        .send(dictonary1)
        .expect(201);

      const dictonary2 = mocks.dictionary();
      let dictonary2Id;
      await request(app)
        .post(endpoints.dictionaries())
        .set(...defaultUser.authData.header)
        .send(dictonary2)
        .expect(201)
        .expect((res) => {
          assert.exists(res.body.item.id, 'item has id');
          dictonary2Id = res.body.item.id;
        });

      await request(app)
        .patch(endpoints.dictionaries(dictonary2Id))
        .set(...defaultUser.authData.header)
        .send({translateDirection: dictonary1.translateDirection})
        .expect(422)
        .expect((res) => {
          delete res.body.originalError;
        })
        .expect({
          message: 'dictionary update error',
          validationErrors: {
            slug: 'dictionary already exist',
          },
        });
    });

    it('should return 422 if dictionary with given title already exist and translateDirection isn`t set', async () => {
      const dictonary1 = mocks.dictionary();
      // delete translateDirection so the slug will be generated by title
      delete dictonary1.translateDirection;
      await request(app)
        .post(endpoints.dictionaries())
        .set(...defaultUser.authData.header)
        .send(dictonary1)
        .expect(201);

      const dictonary2 = mocks.dictionary();
      delete dictonary2.translateDirection;
      let dictonary2Id;
      await request(app)
        .post(endpoints.dictionaries())
        .set(...defaultUser.authData.header)
        .send(dictonary2)
        .expect(201)
        .expect((res) => {
          assert.exists(res.body.item.id, 'item has id');
          dictonary2Id = res.body.item.id;
        });

      await request(app)
        .patch(endpoints.dictionaries(dictonary2Id))
        .set(...defaultUser.authData.header)
        .send({title: dictonary1.title, translateDirection: ''})
        .expect(422)
        .expect((res) => {
          delete res.body.originalError;
        })
        .expect({
          message: 'dictionary update error',
          validationErrors: {
            slug: 'dictionary already exist',
          },
        });
    });

    it('should update only allowed fields if header and payload are valid', async () => {
      const dictonary = mocks.dictionary(5);
      // only those fields can be updated by tested endpoint
      newDict.title = dictonary.title;
      newDict.translateDirection = dictonary.translateDirection;

      await request(app)
        .patch(endpoints.dictionaries(newDict.id))
        .set(...defaultUser.authData.header)
        .send(newDict)
        .expect(200)
        .expect((res) => {
          delete res.body.item.updatedAt;
        })
        .expect({
          message: 'dictionary updated',
          item: {
            ..._.omit(newDict, 'updatedAt'),
            slug: slug(newDict.translateDirection).toLowerCase(),
          },
        });
    });

    it('should return 404 if id is invalid', async () => {
      await request(app)
        .patch(endpoints.dictionaries(mongoose.Types.ObjectId()))
        .set(...defaultUser.authData.header)
        .send(newDict)
        .expect(404);
    });
  });
});
